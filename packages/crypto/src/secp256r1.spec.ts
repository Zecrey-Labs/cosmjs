/* eslint-disable no-bitwise */
import { fromHex } from "@zkkontos/encoding";

import { Secp256r1 } from "./secp256r1";
import { ExtendedSecp256r1Signature, Secp256r1Signature } from "./secp256r1signature";
import { sha256 } from "./sha";

describe("Secp256r1", () => {
  // How to generate Secp256r1 test vectors:
  // $ git clone https://github.com/pyca/cryptography.git && cd cryptography
  // $ python2 -m virtualenv venv
  // $ source venv/bin/activate
  // $ pip install cryptography cryptography_vectors pytest ecdsa
  // $ curl https://patch-diff.githubusercontent.com/raw/webmaster128/cryptography/pull/1.diff | git apply
  //
  // optionally normalize signatures to lowS representation:
  // $ curl https://patch-diff.githubusercontent.com/raw/webmaster128/cryptography/pull/2.diff | git apply
  //
  // $ python ./docs/development/custom-vectors/secp256r1/generate_secp256r1.py > secp256r1_test_vectors.txt

  it("encodes public key uncompressed when making a keypair", async () => {
    // example data generated by OpenSSL (caution: LibreSSL 2.2.7 sometimes adds a leading 00 for the privkey):
    // openssl ecparam -name secp256r1 -genkey | openssl ec -text -noout -conv_form uncompressed
    const privkey = fromHex("5b44b93366536ca29097ad0327d7f8f2da914ba5ab912249882aea77c5ea4992");
    const keypair = await Secp256r1.makeKeypair(privkey);
    expect(keypair.pubkey).toEqual(
      fromHex(
        "041eebbfbdc9417ba609c9dff678f6a0427ec264c24436512abc1ffeec30105e0d318f4e3b587b5951b2f3de27fca3dd02f8793dfb926232edda2a402818ea6259",
      ),
    );
  });

  it("preserves private key when making a keypair", async () => {
    const privkey = fromHex("5b44b93366536ca29097ad0327d7f8f2da914ba5ab912249882aea77c5ea4992");
    const keypair = await Secp256r1.makeKeypair(privkey);
    expect(keypair.privkey).toEqual(
      fromHex("5b44b93366536ca29097ad0327d7f8f2da914ba5ab912249882aea77c5ea4992"),
    );
  });

  it("can load private keys", async () => {
    expect(
      await Secp256r1.makeKeypair(
        fromHex("5b44b93366536ca29097ad0327d7f8f2da914ba5ab912249882aea77c5ea4992"),
      ),
    ).toBeTruthy();
    expect(
      await Secp256r1.makeKeypair(
        fromHex("5b44b93366536ca29097ad0327d7f8f2da914ba5ab912249882aea77c5ea4992"),
      ),
    ).toBeTruthy();
    expect(
      await Secp256r1.makeKeypair(
        fromHex("5b44b93366536ca29097ad0327d7f8f2da914ba5ab912249882aea77c5ea4992"),
      ),
    ).toBeTruthy();

    // smallest and largest allowed values: 1 and N-1 (from https://crypto.stackexchange.com/a/30273)
    expect(
      await Secp256r1.makeKeypair(
        fromHex("0000000000000000000000000000000000000000000000000000000000000001"),
      ),
    ).toBeTruthy();
    expect(
      await Secp256r1.makeKeypair(
        fromHex("ffffffff00000000ffffffffffffffffbce6faada7179e84f3b9cac2fc632550"),
      ),
    ).toBeTruthy();

    // value out of range (too small)
    await Secp256r1.makeKeypair(fromHex("0000000000000000000000000000000000000000000000000000000000000000"))
      .then(() => fail("promise must be rejected"))
      .catch((error) => expect(error.message).toContain("not a valid secp256r1 private key"));
    // value out of range (>= n)
    await Secp256r1.makeKeypair(fromHex("ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"))
      .then(() => fail("promise must be rejected"))
      .catch((error) => expect(error.message).toContain("not a valid secp256r1 private key"));
    await Secp256r1.makeKeypair(fromHex("ffffffff00000000ffffffffffffffffbce6faada7179e84f3b9cac2fc632552"))
      .then(() => fail("promise must be rejected"))
      .catch((error) => expect(error.message).toContain("not a valid secp256r1 private key"));
  });

  it("creates signatures", async () => {
    const privkey = fromHex("5b44b93366536ca29097ad0327d7f8f2da914ba5ab912249882aea77c5ea4992");
    const keypair = await Secp256r1.makeKeypair(privkey);
    const messageHash = new Uint8Array([0x11, 0x22]);
    const signature = (await Secp256r1.createSignature(messageHash, keypair.privkey)).toDer();
    expect(signature).toBeTruthy();
    expect(signature.byteLength).toBeGreaterThanOrEqual(70);
    expect(signature.byteLength).toBeLessThanOrEqual(72);
  });

  it("creates signatures deterministically", async () => {
    const privkey = fromHex("5b44b93366536ca29097ad0327d7f8f2da914ba5ab912249882aea77c5ea4992");
    const keypair = await Secp256r1.makeKeypair(privkey);
    const messageHash = new Uint8Array([0x11, 0x22]);

    const signature1 = await Secp256r1.createSignature(messageHash, keypair.privkey);
    const signature2 = await Secp256r1.createSignature(messageHash, keypair.privkey);
    expect(signature1).toEqual(signature2);
  });

  it("throws for empty message hash in signing", async () => {
    const privkey = fromHex("5b44b93366536ca29097ad0327d7f8f2da914ba5ab912249882aea77c5ea4992");
    const keypair = await Secp256r1.makeKeypair(privkey);
    const messageHash = new Uint8Array([]);
    await Secp256r1.createSignature(messageHash, keypair.privkey)
      .then(() => fail("must not resolve"))
      .catch((error) => expect(error).toMatch(/message hash must not be empty/i));
  });

  it("throws for message hash longer than 32 bytes in signing", async () => {
    const privkey = fromHex("5b44b93366536ca29097ad0327d7f8f2da914ba5ab912249882aea77c5ea4992");
    const keypair = await Secp256r1.makeKeypair(privkey);
    const messageHash = fromHex("11223344556677889900aabbccddeeff11223344556677889900aabbccddeeff11");
    await Secp256r1.createSignature(messageHash, keypair.privkey)
      .then(() => fail("must not resolve"))
      .catch((error) => expect(error).toMatch(/message hash length must not exceed 32 bytes/i));
  });

  it("verifies signatures", async () => {
    const privkey = fromHex("5b44b93366536ca29097ad0327d7f8f2da914ba5ab912249882aea77c5ea4992");
    const keypair = await Secp256r1.makeKeypair(privkey);
    const messageHash = new Uint8Array([0x11, 0x22]);
    const signature = await Secp256r1.createSignature(messageHash, keypair.privkey);

    {
      // valid
      const ok = await Secp256r1.verifySignature(signature, messageHash, keypair.pubkey);
      expect(ok).toEqual(true);
    }

    {
      // messageHash corrupted
      const corruptedMessageHash = messageHash.map((x, i) => (i === 0 ? x ^ 0x01 : x));
      const ok = await Secp256r1.verifySignature(signature, corruptedMessageHash, keypair.pubkey);
      expect(ok).toEqual(false);
    }

    {
      // signature corrupted
      const corruptedSignature = Secp256r1Signature.fromDer(
        signature.toDer().map((x, i) => (i === 5 ? x ^ 0x01 : x)),
      );
      const ok = await Secp256r1.verifySignature(corruptedSignature, messageHash, keypair.pubkey);
      expect(ok).toEqual(false);
    }

    {
      // wrong pubkey
      const otherPrivkey = fromHex("91099374790843e29552c3cfa5e9286d6c77e00a2c109aaf3d0a307081314a09");
      const wrongPubkey = (await Secp256r1.makeKeypair(otherPrivkey)).pubkey;
      const ok = await Secp256r1.verifySignature(signature, messageHash, wrongPubkey);
      expect(ok).toEqual(false);
    }
  });

  it("throws for empty message hash in verification", async () => {
    const dummySignature = Secp256r1Signature.fromDer(
      fromHex(
        "304602210083de9be443bcf480892b8c8ca1d5ee65c79a315642c3f7b5305aff3065fda2780221009747932122b93cec42cad8ee4630a8f6cbe127578b8c495b4ab927275f657658",
      ),
    );
    const keypair = await Secp256r1.makeKeypair(
      fromHex("5b44b93366536ca29097ad0327d7f8f2da914ba5ab912249882aea77c5ea4992"),
    );
    const messageHash = new Uint8Array([]);
    await Secp256r1.verifySignature(dummySignature, messageHash, keypair.pubkey)
      .then(() => fail("must not resolve"))
      .catch((error) => expect(error).toMatch(/message hash must not be empty/i));
  });

  it("throws for message hash longer than 32 bytes in verification", async () => {
    const dummySignature = Secp256r1Signature.fromDer(
      fromHex(
        "304602210083de9be443bcf480892b8c8ca1d5ee65c79a315642c3f7b5305aff3065fda2780221009747932122b93cec42cad8ee4630a8f6cbe127578b8c495b4ab927275f657658",
      ),
    );
    const keypair = await Secp256r1.makeKeypair(
      fromHex("5b44b93366536ca29097ad0327d7f8f2da914ba5ab912249882aea77c5ea4992"),
    );
    const messageHash = fromHex("11223344556677889900aabbccddeeff11223344556677889900aabbccddeeff11");
    await Secp256r1.verifySignature(dummySignature, messageHash, keypair.privkey)
      .then(() => fail("must not resolve"))
      .catch((error) => expect(error).toMatch(/message hash length must not exceed 32 bytes/i));
  });

  describe("recoverPubkey", () => {
    it("can recover pubkey", async () => {
      {
        // Test data from https://github.com/ethereumjs/ethereumjs-util/blob/v6.1.0/test/index.js#L496
        const expectedPubkey = (
          await Secp256r1.makeKeypair(
            fromHex("5b44b93366536ca29097ad0327d7f8f2da914ba5ab912249882aea77c5ea4992"),
          )
        ).pubkey;
        const signature = new ExtendedSecp256r1Signature(
          fromHex("438ce0f6c6d380a93a336fa01bec407131330ce2d352067f60ffd059f1240c4c"),
          fromHex("e40fc0257495fa817d49f87445684d2d81285b980752f636617fea839850df62"),
          0,
        );
        const messageHash = fromHex("82ff40c0a986c6a5cfad4ddf4c3aa6996f1a7837f9c398e17e5de5cbd5a12b28");
        const pubkey = Secp256r1.recoverPubkey(signature, messageHash);
        expect(pubkey).toEqual(expectedPubkey);
      }
      {
        // Test data from https://github.com/randombit/botan/blob/2.9.0/src/tests/data/pubkey/ecdsa_key_recovery.vec
        const expectedPubkeyX = "1eebbfbdc9417ba609c9dff678f6a0427ec264c24436512abc1ffeec30105e0d";
        const expectedPubkeyY = "318f4e3b587b5951b2f3de27fca3dd02f8793dfb926232edda2a402818ea6259";
        const expectedPubkey = fromHex(`04${expectedPubkeyX}${expectedPubkeyY}`);
        const r = fromHex("438ce0f6c6d380a93a336fa01bec407131330ce2d352067f60ffd059f1240c4c");
        const s = fromHex("e40fc0257495fa817d49f87445684d2d81285b980752f636617fea839850df62");
        const signature = new ExtendedSecp256r1Signature(r, s, 0);
        const messageHash = fromHex("82ff40c0a986c6a5cfad4ddf4c3aa6996f1a7837f9c398e17e5de5cbd5a12b28");
        const pubkey = Secp256r1.recoverPubkey(signature, messageHash);
        expect(pubkey).toEqual(expectedPubkey);
      }
    });
  });

  describe("compressPubkey", () => {
    it("throws for a pubkey with invalid length", () => {
      const pubkey = fromHex("aa".repeat(32));
      expect(() => Secp256r1.compressPubkey(pubkey)).toThrowError(/invalid pubkey length/i);
    });

    it("returns a compressed pubkey unchanged", () => {
      const pubkey = fromHex("02d41a0aa167b21699429eab224bc03f2cd386f0af5d20cefbd0336f1544aea24f");
      expect(Secp256r1.compressPubkey(pubkey)).toEqual(pubkey);
    });

    it("compresses an uncompressed pubkey", () => {
      // Test data generated at https://iancoleman.io/bitcoin-key-compression/
      const pubkey = fromHex(
        "044f04181eeba35391b858633a765c4a0c189697b40d216354d50890d350c7029013b587a681e836cc187a8164b98a5848a2b89b3173315fdd0740d5032e259cd5",
      );
      const compressed = fromHex("034f04181eeba35391b858633a765c4a0c189697b40d216354d50890d350c70290");
      expect(Secp256r1.compressPubkey(pubkey)).toEqual(compressed);
    });
  });

  describe("uncompressPubkey", () => {
    it("throws for a pubkey with invalid length", () => {
      const pubkey = fromHex("aa".repeat(32));
      expect(() => Secp256r1.uncompressPubkey(pubkey)).toThrowError(/invalid pubkey length/i);
    });

    it("returns an uncompressPubkey pubkey unchanged", () => {
      // Test data generated at https://iancoleman.io/bitcoin-key-compression/
      const pubkey = fromHex(
        "044f04181eeba35391b858633a765c4a0c189697b40d216354d50890d350c7029013b587a681e836cc187a8164b98a5848a2b89b3173315fdd0740d5032e259cd5",
      );
      expect(Secp256r1.uncompressPubkey(pubkey)).toEqual(pubkey);
    });

    it("uncompresses a compressed pubkey", () => {
      // Test data generated at https://iancoleman.io/bitcoin-key-compression/
      const uncompressed = fromHex(
        "041eebbfbdc9417ba609c9dff678f6a0427ec264c24436512abc1ffeec30105e0d318f4e3b587b5951b2f3de27fca3dd02f8793dfb926232edda2a402818ea6259",
      );
      const compressed = fromHex("031eebbfbdc9417ba609c9dff678f6a0427ec264c24436512abc1ffeec30105e0d");
      expect(Secp256r1.uncompressPubkey(compressed)).toEqual(uncompressed);
    });
  });

  describe("trimRecoveryByte", () => {
    it("throws for a signature with invalid length", () => {
      const signature = fromHex("aa".repeat(66));
      expect(() => Secp256r1.trimRecoveryByte(signature)).toThrowError(/invalid signature length/i);
    });

    it("returns a trimmed signature", () => {
      const signature = fromHex("aa".repeat(64));
      expect(Secp256r1.trimRecoveryByte(signature)).toEqual(signature);
    });

    it("trims a signature with recovery byte", () => {
      const signature = fromHex("aa".repeat(64) + "bb");
      expect(Secp256r1.trimRecoveryByte(signature)).toEqual(fromHex("aa".repeat(64)));
    });
  });
});
